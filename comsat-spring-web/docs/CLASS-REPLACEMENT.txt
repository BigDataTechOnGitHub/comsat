Non-child replacement class with matching interface and maximal reuse (AKA "replacement chain reaction")
========================================================================================================

class O(riginal) extends O(riginal)B(ase) implements I1 ... In { F1 ... Fn, M1 ... Mn }

class R(eplacement) extends R(eplacement)B(ase) implements I1 ... In { ... }

Note: if something in a class must be replaced, then the class must be replaced as well

- RB already replaces OB, else recur up the hierarchy until a common base is reached (Object in the worst case)
- For each field Fx in O:
  - If it's ok leave it there
  - Else replace it with Fx' in R
    - As field access can't be intercepted in Java (AFAIK, maybe through instrumentation?), this means that all methods accessing it must either be made to work on the replaced instance (if possible,
      typically only for some external ones) or be replaced as well
      - If the field is not private, methods accessing it could be in X outside O, this means X too must either be made to work on the replaced instance (if possible) or it needs to be replaced
        - Introspecting code is often "container-level" (or IoC) code which often can't be replaced; in this case the container must be passed the replaced instance
- For each method Mx in O:
  - If it's ok and it needs not to be replaced because of access to replaced fields, forward it to an O instance (if protected, a proxy in the same package is needed)
  - Else replace it
    - If the method is private or final, as private and final method calls can't be intercepted in Java (unless using instrumentation, AFAIK, see strategies below), this means that all methods
      calling it must either be made to work on the replaced instance (if possible, typically only for some external ones) or be replaced as well
      - If the method is not private, methods calling it could be in X outside O, this means X too must either be made to work on the replaced instance (if possible) or it needs to be replaced
        - Introspecting code is often "container-level" (or IoC) code which often can't be replaced; in this case the container must be passed the replaced instance
    - Else the method call can be intercepted and forwarded to a new implementation in R (see strategies below)

Intercepting and forwarding calls to replacement methods
--------------------------------------------------------
Some ideas:
* Instrument the method to be replaced so that it forwards, and do so only for the O instance to be wrapped
  -> Seems not to be possible in JVM, it has to be done for the whole class
* Subclass O and override the method to be replaced so that it forwards, then wrap the O instance after changing its runtime type to the subclass'
  -> Seems not to be possible in JVM and would work only for non-final methods
* Subclass O and override the method so that it forwards, and wrap new subclass instance
  -> Possible only if wrapped subclass instance can be created
